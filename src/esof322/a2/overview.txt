Todd Beckman
Dylan Hills
Kalvyn Lu
Luke O'Neill
Luke Welna

Assignment 2
============

Overall Description of Changes
------------------------------
    The provided code was an collosal nightmare of spaces and tabs. The very
first change was to make all of the code fit a uniform format (4 space indent
and no tabs). This is the agreed-upon format that the group decided to use at
the start of the semester.
    The next change was to pull out the game's listener code into a separate
method so that it could later be modified to behave differently without
affecting the gameplay.
    A new InputListener class was made to interface between objects. The
caller to receive() waits for the caller of send(String message). The test of
this class was the button presses, which calls the model, which in turn sends
the appropriate character to the game. This communication system works in
both directions, so the game is also capable of sending messages with the model
on the receiving end.
    In order to assure that the InputListener functions properly, it must be
initialized and linked to both the game and the model before runtime. Thus,
the view invokes the model's startQuest method (which then invokes the game's)
AFTER initialization of both game and model are finished.
    The model had no way of knowing the current player's inventory and
location. In order to display the player's inventory, the Player variable is
now global. The corresponding getter method was also implemented. The previous
implementation of the GUI did not allow user input. This became a problem when
the player wanted to grab or drop an item and needed to choose which item to
grab or drop. A text box was implemented to fix this. The player can now input
a string into the text box and submit it to the model.
    The model now includes an instance of AdventureGameView. This way the view 
can be edited directly from the model.
    The enter() method in the CaveSite interface (and therefore Room, Door, 
and Wall) now returns a string. This string is displayed in the actionArea in 
the GUI. 
    The GUI now has an ActionArea that displays the action the player made. It 
also displays instructions for grabbing and dropping items.
    The UML was at this stage ready to be generated and so was generated.
    Among the final touches is a change in which the messages are printed
through printView and printAction methods which enforce the same messages in
both terminal and gui game modes while still updating the correct part of the
gui. Commenting, correcting typos, and final debugging touches finished off the
project.


Interesting Class Relationships, Design Approaches, and Troublesome Things
--------------------------------------------------------------------------

    One of the more interesting problems to solve about this project was 
forcing  the game, which is not hooked up to a GUI, to wait for the GUI's 
input instead  of terminal input. To solve this, a separate InputListener 
class was made. It forces the listening class (usually the game class) to 
sleep until a separate input thread (usually the model, triggered by the GUI) 
provides it with the input it was waiting for. This listener is a compact 
class that can be copied for use in future projects due to its simple, elegant 
stucture and its usefulness.
    In order for the classes to communicate correctly, it was necessary for 
the GUI and game to see and be seen by the model, but not with each other. 
However, since the program begins in the GUI, it is necessary to construct the
model from it (and the game from it, without the view knowing). Thus, the 
startQuest method needed to be called from the furthest out layer and fired to 
all other classes in the right order so that initialization worked properly.
    The design of the project was laid out in the specifications, so there were
no real issues with developing this. Keeping the blackboxing in mind led to a
very simple and efficient system that should run from the terminal or through 
the GUI, with the display differences being handled automatically.


Special Running Instructions
----------------------------
    This game supports text-based and graphical user interface. To run the
graphical user interface, run AdventureGameView.main. To run in the console, 
run AdventureGame.main. The game functions for both methods, but you will also
find that there is no redundant display.


Time Spent by each member
-------------------------
Todd Beckman- 3 hours
Luke Welna  - 5 minutes
Kalvyn Lu - 2 hours
Dylan Hills - 2 hours
Luke Oâ€™Neill - 1 hour